var documenterSearchIndex = {"docs":
[{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"EditURL = \"../../../examples/tutorial.jl\"","category":"page"},{"location":"generated/tutorial/#Unit-Disk-Mapping","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"","category":"section"},{"location":"generated/tutorial/#Generic-Unweighted-Mapping","page":"Unit Disk Mapping","title":"Generic Unweighted Mapping","text":"","category":"section"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The generic unweighted mapping aims to reduce a generic unweighted Maximum Independent Set (MIS) problem to one on a defected King's graph. Check our paper (link to be added) for the mapping scheme.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Let the source graph be the Petersen graph.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"using UnitDiskMapping, Graphs, GenericTensorNetworks, LinearAlgebra","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Visualization setup. To make the plots dark-mode friendly, we use white-background color.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"using LuxorGraphPlot.Luxor, LuxorGraphPlot\n\ngraph = smallgraph(:petersen)\n\nLuxorGraphPlot.show_graph(graph)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"We can use the map_graph function to map the unweighted MIS problem on the Petersen graph to one on a defected King's graph.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"unweighted_res = map_graph(graph; vertex_order=MinhThiTrick());\nnothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Here, the keyword argument vertex_order can be a vector of vertices in a specified order, or the method to compute the path decomposition that generates an order. The MinhThiTrick() method is an exact path decomposition solver, which is suited for small graphs (where number of vertices <= 50). The Greedy() method finds the vertex order much faster and works in all cases, but may not be optimal. A good vertex order can reduce the depth of the mapped graph.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The return value contains the following fields:","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"fieldnames(unweighted_res |> typeof)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The field grid_graph is the mapped grid graph.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"LuxorGraphPlot.show_graph(unweighted_res.grid_graph)\n\nunweighted_res.grid_graph.size","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The field lines is a vector of copy gadgets arranged in a ⊢ shape. These copy gadgets form a crossing lattice,  in which two copy lines cross each other whenever their corresponding vertices in the source graph are connected by an edge.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"    vslot\n      ↓\n      |          ← vstart\n      |\n      |-------   ← hslot\n      |      ↑   ← vstop\n            hstop","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"unweighted_res.lines","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The field mapping_history contains the rewrite rules applied to the crossing lattice. They contain important information for mapping a solution back.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"unweighted_res.mapping_history","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The field mis_overhead is the difference between alpha(G_M) - alpha(G_S), where G_M and G_S are the mapped and source graph.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"unweighted_res.mis_overhead","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"We can solve the mapped graph with GenericTensorNetworks.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"res = solve(GenericTensorNetwork(IndependentSet(SimpleGraph(unweighted_res.grid_graph))), SingleConfigMax())[]","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"You might want to read the documentation page of GenericTensorNetworks for a detailed explanation on this function. Here, we just visually check the solution configuration.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_config(unweighted_res.grid_graph, res.c.data)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"By mapping the result back, we get a solution for the original Petersen graph. Its maximum independent set size is 4.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The solution obtained by solving the mapped graph","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"original_configs = map_config_back(unweighted_res, res.c.data)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Confirm that the solution from the mapped graph gives us a maximum independent set for the original graph","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"UnitDiskMapping.is_independent_set(graph, original_configs)","category":"page"},{"location":"generated/tutorial/#Generic-Weighted-Mapping","page":"Unit Disk Mapping","title":"Generic Weighted Mapping","text":"","category":"section"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"A Maximum Weight Independent Set (MWIS) problem on a general graph can be mapped to one on the defected King's graph. The first step is to do the same mapping as above but adding a new positional argument Weighted() as the first argument of map_graph. Let us still use the Petersen graph as an example.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"weighted_res = map_graph(Weighted(), graph; vertex_order=MinhThiTrick());\nnothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The return value is similar to that for the unweighted mapping generated above, except each node in the mapped graph can have a weight 1, 2 or 3. Note here, we haven't added the weights in the original graph.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_grayscale(weighted_res.grid_graph)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The \"pins\" of the mapped graph have a one-to-one correspondence to the vertices in the source graph.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_pins(weighted_res)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The weights in the original graph can be added to the pins of this grid graph using the map_weights function. The added weights must be smaller than 1.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"source_weights = rand(10)\n\nmapped_weights = map_weights(weighted_res, source_weights)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Now that we have both the graph and the weights, let us solve the mapped problem!","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"wmap_config = let\n\tgraph, _ = graph_and_weights(weighted_res.grid_graph)\n\tcollect(Int,\n\t\tsolve(GenericTensorNetwork(IndependentSet(graph, mapped_weights)), SingleConfigMax())[].c.data\n\t)\nend\n\nshow_config(weighted_res.grid_graph, wmap_config)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"By reading the configurations of the pins, we obtain a solution for the source graph.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The solution obtained by solving the mapped graph","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"map_config_back(weighted_res, wmap_config)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Directly solving the source graph","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"collect(Int,\n\tsolve(GenericTensorNetwork(IndependentSet(graph, source_weights)), SingleConfigMax())[].c.data\n)","category":"page"},{"location":"generated/tutorial/#QUBO-problem","page":"Unit Disk Mapping","title":"QUBO problem","text":"","category":"section"},{"location":"generated/tutorial/#Generic-QUBO-mapping","page":"Unit Disk Mapping","title":"Generic QUBO mapping","text":"","category":"section"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"A QUBO problem can be specified as the following energy model:","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"E(z) = -sum_ij J_ij z_i z_j + sum_i h_i z_i","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"n = 6\n\nJ = triu(randn(n, n) * 0.001, 1); J += J'\n\nh = randn(n) * 0.001","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Now, let us do the mapping on an n times n crossing lattice.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"qubo = UnitDiskMapping.map_qubo(J, h);\nnothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The mapping result contains two fields, the grid_graph and the pins. After finding the ground state of the mapped independent set problem, the configuration of the spin glass can be read directly from the pins. The following graph plots the pins in red color.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"qubo_graph, qubo_weights = UnitDiskMapping.graph_and_weights(qubo.grid_graph)\n\nshow_pins(qubo)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"One can also check the weights using the gray-scale plot.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_grayscale(qubo.grid_graph)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"By solving this maximum independent set problem, we will get the following configuration.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"qubo_mapped_solution = collect(Int, solve(GenericTensorNetwork(IndependentSet(qubo_graph, qubo_weights)), SingleConfigMax())[].c.data)\n\nshow_config(qubo.grid_graph, qubo_mapped_solution)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"This solution can be mapped to a solution for the source graph by reading the configurations on the pins.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The solution obtained by solving the mapped graph","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"map_config_back(qubo, collect(Int, qubo_mapped_solution))","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"This solution is consistent with the exact solution:","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Directly solving the source graph, due to the convention issue, we flip the signs of J and h","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"collect(Int, solve(GenericTensorNetwork(spin_glass_from_matrix(-J, -h)), SingleConfigMax())[].c.data)","category":"page"},{"location":"generated/tutorial/#QUBO-problem-on-a-square-lattice","page":"Unit Disk Mapping","title":"QUBO problem on a square lattice","text":"","category":"section"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"We define some coupling strengths and onsite energies on a n times n square lattice.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"square_coupling = [[(i,j,i,j+1,0.01*randn()) for i=1:n, j=1:n-1]...,\n\t[(i,j,i+1,j,0.01*randn()) for i=1:n-1, j=1:n]...];\n\nsquare_onsite = vec([(i, j, 0.01*randn()) for i=1:n, j=1:n]);\nnothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Then we use map_qubo_square to reduce the QUBO problem on a square lattice to the MIS problem on a grid graph.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"qubo_square = UnitDiskMapping.map_qubo_square(square_coupling, square_onsite);\n\nshow_grayscale(qubo_square.grid_graph)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"You can see each coupling is replaced by the following XOR gadget","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_grayscale(UnitDiskMapping.gadget_qubo_square(Int), texts=[\"x$('₀'+i)\" for i=1:8])","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Where dark nodes have weight 2 and light nodes have weight 1. It corresponds to the boolean equation x_8 = neg (x_1 veebar x_5); hence we can add ferromagnetic couplings as negative weights and anti-ferromagnetic couplings as positive weights. On-site terms are added directly to the pins.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_pins(qubo_square)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Let us solve the independent set problem on the mapped graph.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"square_graph, square_weights = UnitDiskMapping.graph_and_weights(qubo_square.grid_graph);\n\nconfig_square = collect(Int, solve(GenericTensorNetwork(IndependentSet(square_graph, square_weights)), SingleConfigMax())[].c.data);\nnothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"We will get the following configuration.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_config(qubo_square.grid_graph, config_square)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"By reading out the configurations at pins, we can get a solution of the source QUBO problem.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"r1 = map_config_back(qubo_square, config_square)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"It can be easily checked by examining the exact result.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"let\n\t# solve QUBO directly\n\tg2 = SimpleGraph(n*n)\n\tJd = Dict{Tuple{Int,Int}, Float64}()\n\tfor (i,j,i2,j2,J) in square_coupling\n\t\tedg = (i+(j-1)*n, i2+(j2-1)*n)\n\t\tJd[edg] = J\n\t\tadd_edge!(g2, edg...)\n\tend\n\n\tJs, hs = Float64[], zeros(Float64, nv(g2))\n\tfor e in edges(g2)\n\t\tpush!(Js, Jd[(e.src, e.dst)])\n\tend\n\tfor (i,j,h) in square_onsite\n\t\ths[i+(j-1)*n] = h\n\tend\n\tcollect(Int, solve(GenericTensorNetwork(SpinGlass(g2, -Js, -hs)), SingleConfigMax())[].c.data)\nend","category":"page"},{"location":"generated/tutorial/#Factorization-problem","page":"Unit Disk Mapping","title":"Factorization problem","text":"","category":"section"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The building block of the array multiplier can be mapped to the following gadget:","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"let\n\tgraph, pins = UnitDiskMapping.multiplier()\n\ttexts = fill(\"\", length(graph.nodes))\n\ttexts[pins] .= [\"x$i\" for i=1:length(pins)]\n\tshow_grayscale(graph)\nend","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Let us denote the input and output pins as x_1-8 in 0 1. The above gadget implements the following equations:","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"beginalign\nx_1 + x_2 x_3 + x_4 = x_5 + 2 x_7\nx_2 = x_6\nx_3 = x_8\nendalign","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"One can call map_factoring(M, N) to map a factoring problem to the array multiplier grid of size (M, N). In the following example of (2, 2) array multiplier, the input integers are p = 2p_2+p_1 and q= 2q_2+q_1, and the output integer is m = 4m_3+2m_2+m_1. The maximum independent set corresponds to the solution of pq = m","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"mres = UnitDiskMapping.map_factoring(2, 2);\n\nshow_pins(mres)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"To solve this factoring problem, one can use the following statement:","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"multiplier_output = UnitDiskMapping.solve_factoring(mres, 6) do g, ws\n\tcollect(Int, solve(GenericTensorNetwork(IndependentSet(g, ws)), SingleConfigMax())[].c.data)\nend","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"This function consists of the following steps:","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"We first modify the graph by inspecting the fixed values, i.e., the output m and 0s:\nIf a vertex is fixed to 1, remove it and its neighbors,\nIf a vertex is fixed to 0, remove this vertex.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"The resulting grid graph is","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"mapped_grid_graph, remaining_vertices = let\n\tg, ws = graph_and_weights(mres.grid_graph)\n\tmg, vmap = UnitDiskMapping.set_target(g, [mres.pins_zeros..., mres.pins_output...], 6 << length(mres.pins_zeros))\n\tGridGraph(mres.grid_graph.size, mres.grid_graph.nodes[vmap], mres.grid_graph.radius), vmap\nend;\n\nshow_graph(mapped_grid_graph)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Then, we solve this new grid graph.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"config_factoring6 = let\n\tmg, mw = graph_and_weights(mapped_grid_graph)\n\tsolve(GenericTensorNetwork(IndependentSet(mg, mw)), SingleConfigMax())[].c.data\nend;\n\nshow_config(mapped_grid_graph, config_factoring6)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"It is straightforward to read out the results from the above configuration. The solution should be either (2, 3) or (3, 2).","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"let\n\tcfg = zeros(Int, length(mres.grid_graph.nodes))\n\tcfg[remaining_vertices] .= config_factoring6\n\tbitvectors = cfg[mres.pins_input1], cfg[mres.pins_input2]\n\tUnitDiskMapping.asint.(bitvectors)\nend","category":"page"},{"location":"generated/tutorial/#Logic-Gates","page":"Unit Disk Mapping","title":"Logic Gates","text":"","category":"section"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"NOT gate: y_1 =neg x_1","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_pins(Gate(:NOT))","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_grayscale(gate_gadget(Gate(:NOT))[1], wmax=2)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"NXOR gate: y_1 =neg (x_1 veebar x_2). Notice this negated XOR gate is used in the square lattice QUBO mapping.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_pins(Gate(:NXOR))","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_grayscale(gate_gadget(Gate(:NXOR))[1], wmax=2)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"NOR gate: y_1 =neg (x_1 vee x_2)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_pins(Gate(:NOR))","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_grayscale(gate_gadget(Gate(:NOR))[1], wmax=2)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"AND gate: y_1 =x_1 wedge x_2","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_pins(Gate(:AND))","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"show_grayscale(gate_gadget(Gate(:AND))[1], wmax=2)","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"Since most logic gates have 3 pins, it is natural to embed a circuit to a 3D unit disk graph by taking the z direction as the time. In a 2D grid, one needs to do the general weighted mapping in order to create a unit disk boolean circuit.","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"","category":"page"},{"location":"generated/tutorial/","page":"Unit Disk Mapping","title":"Unit Disk Mapping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ref/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [UnitDiskMapping]","category":"page"},{"location":"ref/#UnitDiskMapping.CrossPattern","page":"Reference","title":"UnitDiskMapping.CrossPattern","text":"Properties\n\nsize\ncross_location\nsource: (locs, graph, pins/auto)\nmapped: (locs, graph/auto, pins/auto)\n\nRequires\n\nequivalence in MIS-compact tropical tensor (you can check it with tests),\nthe size is <= [-2, 2] x [-2, 2] at the cross (not checked, requires cross offset information),\nancillas does not appear at the boundary (not checked),\n\n\n\n\n\n","category":"type"},{"location":"ref/#UnitDiskMapping.Pattern","page":"Reference","title":"UnitDiskMapping.Pattern","text":"Provides\n\nvisualization of mapping\nthe script for generating backward mapping (project/createmap.jl)\nthe script for tikz visualization (project/vizgadget.jl)\n\n\n\n\n\n","category":"type"},{"location":"ref/#UnitDiskMapping.SimplifyPattern","page":"Reference","title":"UnitDiskMapping.SimplifyPattern","text":"Properties\n\nsize\nsource: (locs, graph/auto, pins/auto)\nmapped: (locs, graph/auto, pins/auto)\n\nRequires\n\nequivalence in MIS-compact tropical tensor (you can check it with tests),\nancillas does not appear at the boundary (not checked),\n\n\n\n\n\n","category":"type"},{"location":"ref/#UnitDiskMapping.embed_graph-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"Reference","title":"UnitDiskMapping.embed_graph","text":"embed_graph([mode,] g::SimpleGraph; vertex_order=MinhThiTrick())\n\nEmbed graph g into a unit disk grid, where the optional argument mode can be Weighted() or UnWeighted. The vertex_order can be a vector or one of the following inputs\n\n* `Greedy()` fast but non-optimal.\n* `MinhThiTrick()` slow but optimal.\n\n\n\n\n\n","category":"method"},{"location":"ref/#UnitDiskMapping.map_config_back-Tuple{MappingResult, Any}","page":"Reference","title":"UnitDiskMapping.map_config_back","text":"map_config_back(map_result, config)\n\nMap a solution config for the mapped MIS problem to a solution for the source problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#UnitDiskMapping.map_configs_back-Tuple{MappingResult, AbstractVector}","page":"Reference","title":"UnitDiskMapping.map_configs_back","text":"map_configs_back(res::MappingResult, configs::AbstractVector)\n\nMap MIS solutions for the mapped graph to a solution for the source graph.\n\n\n\n\n\n","category":"method"},{"location":"ref/#UnitDiskMapping.map_factoring-Tuple{Int64, Int64}","page":"Reference","title":"UnitDiskMapping.map_factoring","text":"map_factoring(M::Int, N::Int)\n\nSetup a factoring circuit with M-bit q register (second input) and N-bit p register (first input). The m register size is (M+N-1), which stores the output. Call solve_factoring to solve a factoring problem with the mapping result.\n\n\n\n\n\n","category":"method"},{"location":"ref/#UnitDiskMapping.map_graph-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"Reference","title":"UnitDiskMapping.map_graph","text":"map_graph([mode=UnWeighted(),] g::SimpleGraph; vertex_order=MinhThiTrick(), ruleset=[...])\n\nMap a graph to a unit disk grid graph that being \"equivalent\" to the original graph, and return a MappingResult instance. Here \"equivalent\" means a maximum independent set in the grid graph can be mapped back to a maximum independent set of the original graph in polynomial time.\n\nPositional Arguments\n\nmode is optional, it can be Weighted() (default) or UnWeighted().\ng is a graph instance, check the documentation of Graphs for details.\n\nKeyword Arguments\n\nvertex_order specifies the order finding algorithm for vertices.\n\nDifferent vertex orders have different path width, i.e. different depth of mapped grid graph. It can be a vector or one of the following inputs     * Greedy() fast but not optimal.     * MinhThiTrick() slow but optimal.\n\nruleset specifies and extra set of optimization patterns (not the crossing patterns).\n\n\n\n\n\n","category":"method"},{"location":"ref/#UnitDiskMapping.map_qubo-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, AbstractVector{T2}}} where {T1, T2}","page":"Reference","title":"UnitDiskMapping.map_qubo","text":"map_qubo(J::AbstractMatrix, h::AbstractVector) -> QUBOResult\n\nMap a QUBO problem to a weighted MIS problem on a defected King's graph, where a QUBO problem is defined by the following Hamiltonian\n\nE(z) = -sum_ij J_ij z_i z_j + sum_i h_i z_i\n\nnote: Note\nThe input coupling strength and onsite energies must be << 1.\n\nA QUBO gadget is\n\n⋅ ⋅ ● ⋅\n● A B ⋅\n⋅ C D ●\n⋅ ● ⋅ ⋅\n\nwhere A, B, C and D are weights of nodes that defined as\n\nbeginalign\nA = -J_ij + 4\nB = J_ij + 4\nC = J_ij + 4\nD = -J_ij + 4\nendalign\n\nThe rest nodes: ● have weights 2 (boundary nodes have weights 1 - h_i).\n\n\n\n\n\n","category":"method"},{"location":"ref/#UnitDiskMapping.map_qubo_restricted-Union{Tuple{AbstractArray{Tuple{Int64, Int64, Int64, Int64, T}, 1}}, Tuple{T}} where T","page":"Reference","title":"UnitDiskMapping.map_qubo_restricted","text":"map_qubo_restricted(coupling::AbstractVector) -> RestrictedQUBOResult\n\nMap a nearest-neighbor restricted QUBO problem to a weighted MIS problem on a grid graph, where the QUBO problem can be specified by a vector of (i, j, i', j', J).\n\nE(z) = -sum_(ij)in E J_ij z_i z_j\n\nA FM gadget is\n\n- ⋅ + ⋅ ⋅ ⋅ + ⋅ -\n⋅ ⋅ ⋅ ⋅ 4 ⋅ ⋅ ⋅ ⋅ \n+ ⋅ - ⋅ ⋅ ⋅ - ⋅ +\n\nwhere +, - and 4 are weights of nodes +J, -J and 4J.\n\n- ⋅ + ⋅ ⋅ ⋅ + ⋅ -\n⋅ ⋅ ⋅ 4 ⋅ 4 ⋅ ⋅ ⋅ \n+ ⋅ - ⋅ ⋅ ⋅ - ⋅ +\n\n\n\n\n\n","category":"method"},{"location":"ref/#UnitDiskMapping.map_qubo_square-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{Tuple{Int64, Int64, Int64, Int64, T1}, 1}, AbstractArray{Tuple{Int64, Int64, T2}, 1}}} where {T1, T2}","page":"Reference","title":"UnitDiskMapping.map_qubo_square","text":"map_qubo_square(coupling::AbstractVector, onsite::AbstractVector) -> SquareQUBOResult\n\nMap a QUBO problem on square lattice to a weighted MIS problem on a grid graph, where the QUBO problem can be specified by\n\na vector coupling of (i, j, i', j', J), s.t. (i', j') == (i, j+1) or (i', j') = (i+1, j).\na vector of onsite term (i, j, h).\n\nE(z) = -sum_(ij)in E J_ij z_i z_j + h_i z_i\n\nThe gadget for suqare lattice QUBO problem is as follows\n\n⋅ ⋅ ⋅ ⋅ ● ⋅ ⋅ ⋅ ⋅ \n○ ⋅ ● ⋅ ⋅ ⋅ ● ⋅ ○ \n⋅ ⋅ ⋅ ● ⋅ ● ⋅ ⋅ ⋅ \n⋅ ⋅ ⋅ ⋅ ○ ⋅ ⋅ ⋅ ⋅ \n\nwhere white circles have weight 1 and black circles have weight 2. The unit distance is 2.3.\n\n\n\n\n\n","category":"method"},{"location":"ref/#UnitDiskMapping.map_simple_wmis-Union{Tuple{T}, Tuple{Graphs.SimpleGraphs.SimpleGraph, AbstractVector{T}}} where T","page":"Reference","title":"UnitDiskMapping.map_simple_wmis","text":"map_simple_wmis(graph::SimpleGraph, weights::AbstractVector) -> WMISResult\n\nMap a weighted MIS problem to a weighted MIS problem on a defected King's graph.\n\nnote: Note\nThe input coupling strength and onsite energies must be << 1. This method does not provide path decomposition based optimization, check map_graph for the path decomposition optimized version.\n\n\n\n\n\n","category":"method"},{"location":"ref/#UnitDiskMapping.map_weights-Union{Tuple{T}, Tuple{T1}, Tuple{MappingResult{<:Node{T1}}, AbstractVector{T}}} where {T1, T}","page":"Reference","title":"UnitDiskMapping.map_weights","text":"map_weights(r::MappingResult{WeightedNode}, source_weights)\n\nMap the weights in the source graph to weights in the mapped graph, returns a vector.\n\n\n\n\n\n","category":"method"},{"location":"ref/#UnitDiskMapping.multiplier-Tuple{}","page":"Reference","title":"UnitDiskMapping.multiplier","text":"multiplier()\n\nReturns the multiplier as a SimpleGridGraph instance and a vector of pins. The logic gate constraints on pins are\n\nx1 + x2x3 + x4 == x5 + 2x7\nx2 == x6\nx3 == x8\n\n\n\n\n\n","category":"method"},{"location":"ref/#UnitDiskMapping.solve_factoring-Tuple{Any, FactoringResult, Int64}","page":"Reference","title":"UnitDiskMapping.solve_factoring","text":"solve_factoring(missolver, mres::FactoringResult, x::Int) -> (Int, Int)\n\nSolve a factoring problem by solving the mapped weighted MIS problem on a unit disk grid graph. It returns (a, b) such that a  b = x holds. missolver(graph, weights) should return a vector of integers as the solution.\n\n\n\n\n\n","category":"method"},{"location":"ref/#UnitDiskMapping.unit_disk_graph-Tuple{AbstractVector, Real}","page":"Reference","title":"UnitDiskMapping.unit_disk_graph","text":"unit_disk_graph(locs::AbstractVector, unit::Real)\n\nCreate a unit disk graph with locations specified by locs and unit distance unit.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = UnitDiskMapping","category":"page"},{"location":"#UnitDiskMapping","page":"Home","title":"UnitDiskMapping","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please check the following examples:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unit Disk Mapping, which contains the examples in \"Quantum Optimization with Arbitrary Connectivity Using Rydberg Atom Arrays\":\nReduction from a generic weighted or unweighted maximum independent set (MIS) problem to that on a King's subgraph (KSG).\nReduction from a generic or square-lattice QUBO problem to an MIS problem on a unit-disk grid graph.\nReduction from an integer factorization problem to an MIS problem on a unit-disk grid graph.\nUnweighted KSG reduction of the independent set problem, which contains the unweighted reduction from a general graph to a King's subgraph. It covers all example graphs in paper: \"Computer-Assisted Gadget Design and Problem Reduction of Unweighted Maximum Independent Set\" (To be published).","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"EditURL = \"../../../examples/unweighted.jl\"","category":"page"},{"location":"generated/unweighted/#Unweighted-KSG-reduction-of-the-independent-set-problem","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"","category":"section"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"This page contains examples from the paper, \"Computer-Assisted Gadget Design and Problem Reduction of Unweighted Maximum Independent Set\".","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"using UnitDiskMapping, Graphs # for mapping graphs to a King's subgraph (KSG)\nusing GenericTensorNetworks # for solving the maximum independent sets\nusing GenericTensorNetworks.ProblemReductions","category":"page"},{"location":"generated/unweighted/#Example-1:-The-5-vertex-graph","page":"Unweighted KSG reduction of the independent set problem","title":"Example 1: The 5-vertex graph","text":"","category":"section"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"The five vertex demo graph in the paper.","category":"page"},{"location":"generated/unweighted/#Step-1:-Prepare-a-source-graph.","page":"Unweighted KSG reduction of the independent set problem","title":"Step 1: Prepare a source graph.","text":"","category":"section"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"the demo graph in the main text","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"function demograph()\n    g = SimpleGraph(5)\n    for (i, j) in [(1, 2), (2, 4), (3, 4), (1, 3), (4, 5), (1, 5)]\n        add_edge!(g, i, j)\n    end\n    return g\nend\n\ng5 = demograph()\n\nshow_graph(g5)","category":"page"},{"location":"generated/unweighted/#Step-2:-Map-the-source-graph-to-an-unweighted-King's-subgraph-(KSG)","page":"Unweighted KSG reduction of the independent set problem","title":"Step 2: Map the source graph to an unweighted King's subgraph (KSG)","text":"","category":"section"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"The vertex order is optimized with the Branching path decomposition algorithm (MinhThi's Trick)","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"g5res = UnitDiskMapping.map_graph(g5; vertex_order=MinhThiTrick())","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"Visualize the mapped KSG graph in terminal","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"print(g5res.grid_graph)","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"or in a plotting plane","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"show_graph(g5res.grid_graph)","category":"page"},{"location":"generated/unweighted/#Step-3:-Solve-the-MIS-size-of-the-mapped-graph","page":"Unweighted KSG reduction of the independent set problem","title":"Step 3: Solve the MIS size of the mapped graph","text":"","category":"section"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"The independent set size can be obtained by solving the SizeMax() property using the generic tensor network method.","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"missize_g5_ksg = solve(GenericTensorNetwork(IndependentSet(SimpleGraph(g5res.grid_graph))), SizeMax())[]","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"The predicted MIS size for the source graph is:","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"missize_g5_ksg.n - g5res.mis_overhead","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"One of the best solutions can be obtained by solving the SingleConfigMax() property.","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"mis_g5_ksg = solve(GenericTensorNetwork(IndependentSet(SimpleGraph(g5res.grid_graph))), SingleConfigMax())[].c.data","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"Plot the solution","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"show_config(g5res.grid_graph, mis_g5_ksg)","category":"page"},{"location":"generated/unweighted/#Step-4:-Map-the-KSG-solution-back","page":"Unweighted KSG reduction of the independent set problem","title":"Step 4: Map the KSG solution back","text":"","category":"section"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"In the following, we will show how to obtain an MIS of the source graph from that of its KSG reduction.","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"mis_g5 = UnitDiskMapping.map_config_back(g5res, collect(mis_g5_ksg))","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"Show that the overhead in the MIS size is correct","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"Verify the result:","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"the extracted solution is an independent set","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"UnitDiskMapping.is_independent_set(g5, mis_g5)","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"and its size is maximized","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"count(isone, mis_g5)\n\nsolve(GenericTensorNetwork(IndependentSet(g5)), SizeMax())[].n","category":"page"},{"location":"generated/unweighted/#Example-2:-The-Petersen-graph","page":"Unweighted KSG reduction of the independent set problem","title":"Example 2: The Petersen graph","text":"","category":"section"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"We just quickly go through a second example, the Petersen graph.","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"petersen = smallgraph(:petersen)\n\nshow_graph(petersen)","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"We first map it to a grid graph (unweighted).","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"petersen_res = UnitDiskMapping.map_graph(petersen)","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"The MIS size of the petersen graph is 4.","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"missize_petersen = solve(GenericTensorNetwork(IndependentSet(petersen)), SizeMax())[]","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"The MIS size of the mapped KSG graph is much larger","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"missize_petersen_ksg = solve(GenericTensorNetwork(IndependentSet(SimpleGraph(petersen_res.grid_graph))), SizeMax())[]","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"The difference in the MIS size is:","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"petersen_res.mis_overhead","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"Find an MIS of the mapped KSG and map it back an MIS on the source graph.","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"mis_petersen_ksg = solve(GenericTensorNetwork(IndependentSet(SimpleGraph(petersen_res.grid_graph))), SingleConfigMax())[].c.data\n\nmis_petersen = UnitDiskMapping.map_config_back(petersen_res, collect(mis_petersen_ksg))","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"The obtained solution is an independent set and its size is maximized.","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"UnitDiskMapping.is_independent_set(petersen, mis_petersen)\n\ncount(isone, mis_petersen)","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"The number printed should be consistent with the MIS size of the petersen graph.","category":"page"},{"location":"generated/unweighted/#Extension:-ProblemReductions","page":"Unweighted KSG reduction of the independent set problem","title":"Extension: ProblemReductions","text":"","category":"section"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"Unit-disk mapping implements the unified interface for reduction in package ProblemReductions.jl as an extension.","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"Step 1: perform the problem reduction.","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"source_problem = IndependentSet(smallgraph(:petersen))","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"the Independent set problem with 2D GridGraph topology, unweighted.","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"target_problem_type = IndependentSet{ProblemReductions.GridGraph{2}, Int, UnitWeight}","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"the result not only contains the target problem, but also the intermediate information","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"reduction_result = reduceto(target_problem_type, source_problem)\n\ntarget_problem(reduction_result)","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"Step 2: solve the target problem.","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"get single maximum independent set of the mapped problem","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"config = solve(GenericTensorNetwork(target_problem(reduction_result)), SingleConfigMax())[].c.data","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"Step 3. Extract the solution back","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"extracted_config = extract_solution(reduction_result, config)","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"finally, we check the validity of the solution.","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"UnitDiskMapping.is_independent_set(source_problem.graph, extracted_config)","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"","category":"page"},{"location":"generated/unweighted/","page":"Unweighted KSG reduction of the independent set problem","title":"Unweighted KSG reduction of the independent set problem","text":"This page was generated using Literate.jl.","category":"page"}]
}
