using UnitDiskMapping, GraphTensorNetworks

function mapped_entry_to_compact(s::Pattern)
    locs, g, pins = mapped_graph(s)
    a = solve(Independence(g; openvertices=pins), "size max")
    b = mis_compactify!(copy(a))
    n = length(a)
    d = Dict{Int,Int}()  # the mapping from bad to good
    for i=1:n
        val_a = a[i]
        if iszero(b[i]) && !iszero(val_a)
            bs_a = i-1
            for j=1:n # search for the entry b[j] compactify a[i]
                bs_b = j-1
                if b[j] == val_a && (bs_b & bs_a) == bs_b  # find you!
                    d[bs_a] = bs_b
                    break
                end
            end
        else
            d[i-1] = i-1
        end
    end
    return d
end

# from mapped graph bounary configuration to compact bounary configuration
function source_entry_to_configs(s::Pattern)
    locs, g, pins = source_graph(s)
    a = solve(Independence(g, openvertices=pins), "configs max")
    d = Dict{Int,Vector{BitVector}}()  # the mapping from bad to good
    for i=1:length(a)
        d[i-1] = [BitVector(s) for s in a[i].c.data]
    end
    return d
end

# from bounary configuration to MISs.
function generate_mapping(s::Pattern)
    d1 = mapped_entry_to_compact(s)
    d2 = source_entry_to_configs(s)
    s = """function mapped_entry_to_compact(::$(typeof(s)))
    return Dict($(collect(d1)))
end

function source_entry_to_configs(::$(typeof(s)))
    return Dict($(collect(d2)))
end
"""
end

function dump_mapping_to_julia(filename, patterns)
    s = join([generate_mapping(p) for p in patterns], "\n\n")
    open(filename, "w") do f
        write(f, "# Do not modify this file, because it is automatically generated by `project/createmap.jl`\n\n" * s)
    end
end

dump_mapping_to_julia(joinpath(@__DIR__, "..", "src", "extracting_results.jl"),
    (Cross{false}(), Cross{true}(), TShape{true}(), TShape{false}(),
    Turn(), WTurn(), Branch(), BranchFix(), TrivialTurn(), TCon(), BranchFixB()))